# Git

Git — это программа, которая в том числе может работать из командной строки. 

Ниже представлены основные наиболее часто используемые команды для работы в командной строке (Git Bash)

### Команды для перемещения по файловой системе

- pwd (от англ. print working directory — «показать рабочую папку») - показать, где именно в файловой системы мы находимся
- cd (от англ. change directory — «сменить директорию») + адрес директории - перейти к указанной директории
- ~ - обозначение домашней директории
- cd ~ - перейти в домашнюю директорию
- ls (от англ. list directory contents — «отобразить содержимое директории») - показать содержимое директории
- ls -a - показать расширенное содержимое директории (со скрытыми файлами)
- . - обратиться к текущей директории
- .. - вернуться на уровень выше



### Команды для работы с файлами и папками

- touch %ИМЯ_ФАЙЛА% - создать файл
- mkdir %ИМЯ_ПАПКИ% (от англ. make directory — «создать директорию») - создать папку
- mkdir -p dir1/dir-inside/dir-deeper-inside - создать струтура директорий
- cp index.html src/ - копировать (что копировать и куда копировать)
- mv переместить (что переместить и куда переместить)
- cat (от англ. concatenate and print — «объединить и распечатать») чтение файла (только для текстовых файлов)
- rm (от англ. remove — «удалить») - удалить файл
- rmdir (от англ. remove directory — «удалить директорию») - удалить папку
- rm -r - удалить непустую папку со всем содержимым

**rm и rmdir удаляют безвозвратно (миную корзину)**

- Tab - автоматически допишет команду или путь
- стрелочки ↑ и  ↓ - вызов предыдущих команд из буфера



### Команды для работы с Git

- git config --global user.name "ваше имя или ник латиницей" 
- git config --global user.email ваша электронная почта
- git init - сделать папку репозиторием
- rm -rf .git - «разгитить» папку (удалить папку .git)
- git status - проверить состояние репозитория
- git add %ИМЯ_ФАЙЛА% - подготовить файл к сохранению
- git add --all - подготовить все файлы в репозитории к сохранению
- git commit - выполнить коммит
- git log - посмотреть историю коммитов



### Работа с удаленным репозиторием (например GitHub)

#### Создание SSH-ключей

- Приватный ключ (англ. private key) хранится только на вашем компьютере и не должен передаваться кому-либо ещё. Он используется для расшифровки данных.
- Публичный ключ (англ. public key) доступен всем и используется для шифрования данных. Они могут быть расшифрованы парным приватным ключом.
- ls -la .ssh/ - проверить наличие уже созданных SSH-ключей
- ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" - генерация SSH-пары
- ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" - генерация SSH-пары
- clip < ~/.ssh/id_rsa.pub (или clip < ~/.ssh/id_ed25519.pub) - скопировать в буфер обмена содержимое файла с публичным ключем
- далее это содержимое необходимо вставить на GitHub в разделе Settings -> SSH and GPG keys -> New SSH key

#### Команды для работы с удаленным репозиторием

- git remote add git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ_РЕПОЗИТОРИЯ% - привязать удалённый репозиторий к локальному
- git remote -v - убедиться, что репозитории связаны
- git push - отправить изменения на удалённый репозиторий (после того, как сделан коммит). в первый раз: git push -u origin main/master
- git clone %ССЫЛКА_НА_РЕПОЗИТОРИЙ% - конировать репозиторий (есть если в GitHub-репозитории что-то поменяется (например, добавятся коммиты), вам не нужно будет заново клонировать его. Достаточно будет выполнить команду, которая обновит вашу копию.)
- Fork - GitHub-операция создаёт копию репозитория в аккаунте GitHub. Такая копия будет полностью независима. Изменения, которые вы внесёте, не будут синхронизированы с исходным репозиторием.
- «форк» + clone используется для внесения изменений в публичные репозитории


### Работа с JDK

- javac (сокращённо от java compile) - компилятор, создаст файл .class с байт кодом

наприммер  javac -encoding UTF-8 HelloJdk.java

- javac -d bin -encoding UTF-8 *.java - компиляция, если файлов в папке много

Опция -d <имя папки> (от англ. directory — «папка, каталог») соберёт все сгенерированные class-файлы в одну папку. В нашем примере это папка с именем bin (от англ. binary — «двоичный», так как байт-код хранится в двоичном формате), которая будет создана автоматически. А *.java означает, что скомпилированы будут все файлы с расширением .java, которые находятся в текущей папке — src.

- java -Dfile.encoding=UTF-8 HelloJdk - запустить файл с байт-кодом
- java -cp bin Practicum - запустить. cp - (от англ. classpath — «путь к папке с class-файлами»), bin - имя папки, в которой лежат class-файлы, Practicum - стартовый класс (с методом main)

- jar cfe <имя jar-файла> <имя стартового класса> <список файлов> - создать jar

c (от англ. create — «создавать») указывает на то, что создаётся новый файл;

f (от англ. filename — «имя файла») предупреждает, что после него будет написано имя создаваемого jar-файла;

e (от англ. entrypoint — «точка входа») указывает на название класса, с которого нужно начать выполнение программы.

- java -jar library.jar - запустить jar






## Работа с коммитами


### Хеш

Информация о коммите — это набор данных: когда был сделан коммит, содержимое файлов в репозитории на момент коммита и ссылка на предыдущий, или родительский (англ. parent), коммит. Git хеширует (преобразует) эту информацию с помощью алгоритма SHA-1 (от англ. Secure Hash Algorithm — «безопасный алгоритм хеширования») и получает для каждого коммита свой уникальный хеш — результат хеширования.

Длина хеша - 40 символов (для SHA-1)

Хеш обладает следующими важными свойствами:

- если хеш получить дважды для одного и того же набора входных данных, то результат будет гарантированно одинаковый;

- если хоть что-то в исходных данных поменяется (хотя бы один символ), то хеш тоже изменится (причём сильно).


Git хранит таблицу соответствий хеш → информация о коммите.

Хеши и таблица хранятся в слуэебной папке .git

git log --oneline - команда вызова сокращенного лога. При этом в терминале появятся только первые несколько символов хеша каждого коммита и комментарии к ним.

Команда автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь


### HEAD

Это один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый)/

Внутри HEAD — ссылка на служебный файл: refs/heads/master. Если заглянуть в этот файл, можно увидеть хеш последнего коммита.

Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит.



### Статусы файлов

Проверять состояние файлов можно командой git status.

Статусы могут быть:

- untracked (англ. «неотслеживаемый»)

Новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add.

- staged (англ. «подготовленный»)

После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.

Staging area также называют index (англ. «каталог») или cache (англ. «кеш»), а состояние файла staged иногда называют indexed или cached.

- tracked (англ. «отслеживаемый»)

Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения.

- modified (англ. «изменённый»)

Состояние modified значит, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

**важно**

Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging. Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз.


**Типичный жизненый путь файла**

1. Файл только что создали. Git ещё не отслеживает его содержимое. 

	Состояние: untracked.

2. Файл добавили в staging area с помощью git add. 

	Состояние: staged (+ tracked).

 a. Возможно, изменили файл ещё раз.

	Состояния: staged, modified (+ tracked).

 Обратите внимание: staged и modified у одного файла, но у разных его версий.  

 b. Ещё раз выполнили git add. 
	
	Состояние: staged (+ tracked).

3. Сделали коммит с помощью git commit. 

	Состояние: tracked.

4. Изменили файл. 

	Состояние: modified (+ tracked).

5. Снова добавили в staging area с помощью git add. 

	Состояния: staged (+ tracked).

6. Сделали коммит. 

	Состояния: tracked.

7. Повторили пункты 4−7 много-много раз.



### Сообщения к коммитам

Сделать сообщение к коммиту: git commit -m "Текст сообщения"

Есть общие рекомендации по тому, как правильно составить сообщение. Оно должно быть:

- относительно коротким, чтобы его было легко прочитать;

- информативным.

Все люди разные и у всех есть предпочтения — в том числе, как формулировать сообщения коммитов. Кто-то использует инфинитивы: Исправить сообщение об ошибке E123, кто-то — глаголы в прошедшем времени: Исправил…, кто-то — существительные: Исправление….Чтобы упростить работу, команды или даже целые компании часто договариваются об определённом стиле (то есть о правилах) оформления сообщений коммитов.


**Корпоративный подход к оформлению сообщений коммитов"

Во многих компаниях применяется Jira — система для организации проектов и задач. У каждой задачи в Jira есть идентификатор из нескольких заглавных латинских букв и номера. Например, LGS-239 значит, что это 239-я задача в проекте LGS (сокращение от англ. logistics — «логистика»).

В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения.


**Conventional Commits**

Стандарт Conventional Commits (англ. «соглашение о коммитах») отличается качественной документацией и подробной проработкой. Он подходит для репозиториев с исходным кодом программ. А вот использовать его для других типов проектов было бы неудобно.

Conventional Commits предлагает такой формат коммита: <type>: <сообщение>. Первая часть type — это тип изменений. Таких типов достаточно много. Вот два примера:

- feat (сокращение от англ. feature) — для новой функциональности;
- fix (от англ. «исправить», «устранить») — для исправленных ошибок.

Более подробный список можно увидеть на сайте с описанием этого стиля: https://www.conventionalcommits.org/ru/v1.0.0-beta.4/#%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F

**GitHub-стиль**

GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка задач (англ. issue) этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё. Для этого в любом месте сообщения нужно указать #<номер задачи>. Например, вот так.

git commit -m "Исправить #334, добавить график температуры" 

